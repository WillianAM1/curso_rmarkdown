# Executando Código

## Introdução

## Flags

Veja abaixo algumas flags que são costumeiramente utilizadas em nossos relatórios.
<p>Para encontrar mais flags para o seu relatório acesse a [documentação](https://yihui.name/knitr/options) do **knitr**.</p>

`eval`: Não executa o chunk quando recebe o parâmetro `FALSE`, porém o código do chunk será exibido no arquivo final.

`echo`: Se recebe o parâmetro `FALSE`, o código chunk será executado, mas não exibido no relatório.

`results`: Modifica a saída de código chunk. Para essa flag temos os seguntes parâmetros: `markup`,  `hold`, `asis` e `hide`. Veja nos exemplos a seguir as modificações decorrentes dos diferentes parâmetros.

`results='markup'`:
```{r results='markup'}

print("Curso de R markdown")

```

`results="hold"`:
```{r results='hold'}

print("Curso de R markdown")

```

`results='asis'`:
```{r results='asis'}

print("Curso de R markdown")

```

`results='hide'`:
```{r results='hide'}

print("Curso de R markdown")

```

`collapse`: Comprime o código do chunk e sua saída em apenas um bloco de código no relatório final. Exemplo:

`coollapse=TRUE`:
```{r collapse=TRUE}
print("Curso de R markdown")

```

`warning` e `message`: Quando recebem o parâmetro `FALSE`, não será exibido mensagens ou avisos decorrentes de algum código do chunk no relatório final.

`error`: Usando o parâmetro `TRUE`, se houver algum erro no código do chunk, será exibido no relatório final.

`include`: Quando recebe o parâmetro `FALSE`, oculta o código e o resultado do chunk, mas o código será executado.

`cache`: Códigos podem ser compilados e seus resultados armazenados em cache. Se o código não for alterado, não sera necessário compila-lo novamente.

`fig.width and fig.height` ou `fig.dim=c(x,y)`: Dimensiona o tamanho da figura em polegadas. Exemplo: `fig.width=2 and fig.height=2` ou `fig.dim=c(2,2)`.

`out.width and out.height`: Dimensiona a figura com a porcentagem da altura e largura desejada. Exemplo: `out.width="20%"`.

`fig.aligh`: Define o alinhamento da figura na página. Isso ocorre de acordo com os parâmetros: `left`, `center`, `right` e `left`.

`dev`: Altera o formato de arquivo das figuras do relatório. Podemos usar os parâmetros: `’svg’`, `’jpeg’`, `'pdf'`, `’png’`, `’bmp’`, entre outros.

`fig.cap`: Adiciona legenda em figuras do relatório. A legenda será passada como parâmetro desta maneira: `fig.cap=”legenda”`.

`child`: Podemos rodar outro arquivo.Rmd dentro de um novo código. Ideal para ser usado em trabalhos longo que necessitem de maior organização. Para acessar o arquivo.Rmd desejado é preciso passar seu endereço como parâmetro, deste modo:`child=“endereço//arquivo.Rmd”`.


## Linguagens Suportadas

Por meio do pacote knitr que forneceu um grande número de motores de linguagem o R Markdown suporta outras linguagens tais como [Python](https://www.python.org/), [Julia](https://julialang.org/), C++, SQL. Esses motores de linguagem podem ser acessados dentro de blocos de código designando sua respectiva engine, as engines no knitr são:

```{r}
names(knitr::knit_engines$get())
```

### Linguagem Python

Para utilizar a linguagem python primeiro é necessário instalar o pacote reticulate com o comando:
```{r, eval = FALSE}
install.packages("reticulate")
```

Com esse pacote é possível executar todos os fragmentos de código Python em uma mesma seção. Caso deseje executar um trecho do código pode usar o comando:

`python.reticulate = FALSE`

Vale ressaltar que se você estiver usando uma versão do knitr inferior a 1.18 você deve atualizar seus pacotes R. Por padrão o reticulate usa a versão padrão encontrada em seu path. Para encontrar onde esta instalado o python em seu computador use o comando:

```{r, eval = FALSE}
Sys.which("python")
```

Você pode escolher a versão de Python com o comando:

```{r, eval = FALSE}
use_python()
```

Vejamos no exemplo 1 como você pode fazer:

Exemplo 1:

```{r, eval = FALSE}
library(reticulate)
use_python("/usr/local/bin/python")
```

Vejamos no exemplo 2 para usar pedaços de código Python. Outrossim, para isso você deve utilizar o comando

```{r, eval = FALSE}
py$name 
```

Onde `name` é o nome da variável que você deseja usar na sessão Python. Para recuperar um valor Python use também py$name. 

Exemplo 2:

Um pedaço de código R normal

```{r}
x <- 42
print(x)
```

No exemplo 3 vemos a utilização de um pedaço de um código python 

Exemplo 3:

```{python teste}
x = 42 * 2
print(x)
```

O valor de `x` na sessão Python é py$x. Não é o mesmo `x` de R.

### Script Shell

Você pode escrever scripts Shell em R Markdown, se seu sistema puder executá-los (o bash executável ou sh deve existir). Normalmente, isso não é um problema para usuários de Linux ou macOS. Não é impossível para os usuários do Windows, mas você terá que instalar software adicional (como Cygwin ou o Subsistema Linux).

### SQL

Como o mecanismo SQL usa o pacote DBI você deve estabelecer uma conexão DBI com um banco de dados. Você pode utilizar o comando 

```{r, eval = FALSE}
DBI::dbConnect()
```

Você pode usar essa conexão em um fragmento SQL através da opção de conexão como mosta o exemplo 4 utilizando SQLite.

Exemplo 4:

```{r, eval = FALSE}
library(DBI)
db = dbConnect(RSQLite::SQLite(), dbname = "sql.sqlite")
```

Onde `sql.sqlite` é o nome do arquivo sqlite.

````markdown
`r ''` ```{sql, connection = db}
SELECT * FROM trials
```
````

O número de registros exibidos é controlado pela opção `max.print` que é derivada da função sql.max.print.

No exemplo 5 o seguinte fragmento de código exibe os 15 primeiros registros.

````markdown
`r ''` ```{sql, connection=db, max.print = 15}
SELECT * FROM trials
```
````

Caso queria especificar para nenhum limite no registro utilize `max.print = NA`.

Se você quiser atribuir os resultados da consulta SQL a um objeto R como um quadro de dados basta utilizar o comando `output.var`.

Como mostra o exemplo 6

````markdown
`r ''` ```{sql, connection=db, output.var="trials"}
SELECT * FROM trials
```
````

Quando os resultados de uma consulta SQL são atribuídos a um quadro de dados, nenhum registro será impresso no documento. Caso queira, você pode imprimir manualmente o quadro de dados em um bloco R subsequente. Se você precisar ligar os valores das variáveis R em consultas SQL, você pode fazer isso prefaciando a variável R referências com uma interrogação (?). Assim como mostra o exemplo 7.

```{r}
subjects = 10
```

````markdown
`r ''` ```{sql, connection=db, output.var="trials", eval = FALSE}
SELECT * FROM trials WHERE subjects >= ?subjects
```
````

Se você tiver muitos fragmentos SQL, pode ser útil definir um padrão para a opção de fragmento de conexão no fragmento de configuração, de forma que não seja necessário especificar a conexão em cada fragmento individual. Você consegue conforme mostra o exemplo 8.

```{r, eval = FALSE}
library(DBI)
db = dbConnect(RSQLite::SQLite(), dbname = "sql.sqlite")
knitr::opts_chunk$set(connection = "db")
```

Observe que a opção de conexão deve ser uma string nomeando o objeto de conexão (não o próprio objeto). Depois de definido, você pode executar blocos SQL sem especificar uma conexão explícita como mostra o exemplo 9.

````markdown
`r ''` ```{sql}
SELECT * FROM trials
```
````

### Rcpp

O mecanismo Rcpp permite a compilação de C ++ em funções R com o comando `rcpp::sourceCpp()`

O resultado é apresentado no exemplo 10.

````markdown
`r ''` ```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
return x * 2;
}
```
````

A execução desse trecho compilará o código e tornará a função C ++ com o comando:

timesTwo () 

Disponível para R. Você pode armazenar em cache a compilação de blocos de código C ++ usando o cache de knitr padrão, ou seja, adicionar o comando:

cache = TRUE

Conforme mostra o exemplo 11. 

````markdown
`r ''` ```{Rcpp, cache=TRUE}
#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
return x * 2;
}
```
````

Em alguns casos, é desejável combinar todos os pedaços de código Rcpp em um documento em uma única unidade de compilação, pois economiza tempo. Para isso use o comando `ref.label` junto com o comando `knitr::all_rcpp_labels()`.

Pois assim é possível coletar todos os fragmentos do Rcpp conforme mostra o exemplo 12

## Todos os fragmentos de códigos C++ serão combinados em um único fragmento.
````markdown
`r ''` ```{Rcpp, ref.label=knitr::all_rcpp_labels(), include=FALSE}
```
````

Primeiro é necessário incluir o leitor `Rcpp.h`

```{Rcpp, eval=FALSE}
#include <Rcpp.h>
```

Depois você define a função

```{Rcpp, eval=FALSE}
// [[Rcpp::export]]
int timesTwo(int x) {
return x * 2;
}
```

Assim os dois fragmentos com código Rcpp serão compilados juntos no primeiro pedaço.

### Stan 

A linguagem Stan permite a incorporação da linguagem probabilística. Para tanto, utilize o comando:

output.var 

Como mostra o exemplo 13

```{stan, output.var="ex1", eval = FALSE}
parameters {
real y[2];
}
model {
y[1] ~ normal(0, 1);
y[2] ~ double_exponential(0, 2);
}
```
```{r, eval = FALSE}
library(rstan)
fit = sampling(ex1)
print(fit)
```

### Java Script

Se você visa que seu documento tenha saída HTML, é possível executar um Java Script nele usando esta linguagem denominada js.
O exemplo 14 apresenta como mudar a cor do título para vermelho.

```{js, echo=FALSE}
$('.title').css('color', 'red')
```
Da mesma forma, você pode incorporar regras CSS no documento de saída. Por exemplo, o seguinte fragmento de código transforma
texto dentro do corpo do documento vermelho:

```{css, echo=FALSE}
body {
color: red;
}
```

### Julia

A linguagem Julia é suportado pelo pacote JuliaCall igual a linguagem python. Vejamos o exemplo 15 abaixo

```{julia}
a = sqrt(2); # the semicolon inhibits printing
```

### C and Fortran

Para blocos de código que usam C ou Fortran, o knitr usa R CMD SHLIB para compilar o código e carregar o objeto (um arquivo * .so no Unix ou * .dll no Windows). Então você pode usar o comando

 .C () / .Fortran ()

 Para chamar as funções C / Fortran conforma mostra o exemplo 16.

```{c, test-c, results='hide'}
void square(double *x) {
*x = *x * *x;
}
```
Test the `square()` function:
```{r}
.C('square', 9)
.C('square', 123)
```



<!-- citacoes **bookdown** [@R-bookdown] -->
<!-- Só pra ficar claro se alguem ler essa parte aqui, esse negócio esquisito é um comentário -->

## Exemplo
Para que o código seja executado no meio de um texto, é necessário usar o caractere `` ` ``, antes e depois do código descrito. Exemplo:

```{r, eval = FALSE, echo = TRUE}
Este texto gera: `r format(Sys.Date(), "%d/%m/%Y")`.
```

Este texto gera: `r format(Sys.Date(), "%d/%m/%Y")`.

***

O código também pode ser executado dentro de blocos. Blocos de código são inseridos da seguinte forma:
````markdown
`r ''````{r}
format(Sys.Date(), "%d/%m/%Y")
```
````

O que gera o seguinte output ao ser compilado seu arquivo R Markdown:

```{r}
format(Sys.Date(), "%d/%m/%Y")
```

***

Algumas das opções básicas de blocos de código [já mencionadas](#flags):
````markdown
`r ''````{r, echo = FALSE}
2 + 2
```
````

```{r, echo = FALSE}
2 + 2
```

````markdown
`r ''````{r, eval = FALSE}
2 + 2
```
````

```{r, eval = FALSE}
2 + 2
```

***

Exemplo de utilização de blocos de código para inserir imagens como descrito no [capítulo 2](#inserindo-imagens)

````markdown
`r ''````{r}
knitr::include_graphics("img/logoestats.jpeg")
```
````

```{r}
knitr::include_graphics("img/logoestats.jpeg")
```

***

Inserindo tabelas dentro de blocos de código:
````markdown
`r ''````{r}
knitr::kable(cars[1:5,], caption = "Carros")
```
````

```{r}
knitr::kable(cars[1:5,], caption = "Carros")
```

***

Exemplo utilizando outra [linguagem suportada](#linguagens-suportadas), neste caso python:
````markdown
`r ''````{python}
print(5 ** 3)
```
````

```{python}
print(5 ** 3)
```

***

Exemplos mais detalhados de R e de outras linguagens suportadas estão disponíveis neste [link](exemplos/104-intro_blocos_de_codigo.html).
